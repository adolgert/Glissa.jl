<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>B-splines · Glissa.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://adolgert.github.io/Glissa.jl/bsplines/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Glissa.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../notation/">Notation</a></li><li class="is-active"><a class="tocitem" href>B-splines</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#B-spline-definition-from-its-constraints"><span>B-spline definition from its constraints</span></a></li><li><a class="tocitem" href="#How-to-count-B-splines-with-multiplicity"><span>How to count B-splines with multiplicity</span></a></li><li><a class="tocitem" href="#Calculating-B-splines"><span>Calculating B-splines</span></a></li></ul></li><li><a class="tocitem" href="../testspaces/">Testing B-splines</a></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../projectplan/">Project Plan</a></li><li><a class="tocitem" href="../testplan/">Test Plan</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>B-splines</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>B-splines</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/adolgert/Glissa.jl/blob/main/docs/src/bsplines.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="B-splines"><a class="docs-heading-anchor" href="#B-splines">B-splines</a><a id="B-splines-1"></a><a class="docs-heading-anchor-permalink" href="#B-splines" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/B-spline">Wikipedia B-spline</a> article tells you how to calculate them but doesn&#39;t describe what defines a B-spline. That definition will be useful for deriving, understanding, and testing algorithms, so let&#39;s cover it here.</p><h3 id="Compare-with-polynomials-for-interpolation"><a class="docs-heading-anchor" href="#Compare-with-polynomials-for-interpolation">Compare with polynomials for interpolation</a><a id="Compare-with-polynomials-for-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Compare-with-polynomials-for-interpolation" title="Permalink"></a></h3><p>The <a href="../notation/#Notation">Notation</a> section described polynomial splines as a set of polynomials defined on neighboring intervals. For computational purposes, we don&#39;t usually represent polynomial splines as a list of polynomial constants. Instead, we use B-splines, because they are a more compact representation and offer advantages for computations using polynomial splines.</p><p>On an axis with points at <code>(0, 1, 2, 3, 4)</code>, with free boundary conditions, there are 6 degree-2 B-splines.</p><p><img src="order3splines.png" alt="Order 3 Splines"/></p><p>Each B-spline is a function that&#39;s defined over the whole interval, but, at the same time, it&#39;s only non-zero over at-most <span>$d$</span> contiguous intervals.</p><p>Imagine that our goal is to fit data with a polynomial spline. We have points to fit, and they are between some <span>$x_1$</span> and <span>$x_{k+2}$</span>, where we call the endpoint <span>$k+2$</span> so that the count of internal knots is <span>$k$</span>. The first step is to divide the axis into intervals. At each knot where intervals meet, we get to decide, beforehand, whether the fit polynomial should be <span>$C^0$</span>-smooth (continuous), <span>$C^1$</span>-smooth (once differentiable), or as smooth as possible <span>$C^{d-1}$</span>-smooth. We can choose this knot-by-knot, if we want.</p><p>Now how would we do this fit with polynomials? For each interval, there is a separate polynomial <span>$y_j$</span>.</p><p class="math-container">\[y_j(x) = \sum_{i=1}^{i=m} c_{ij} (x-x_j)^{i-1}\]</p><p>We could fit the points in order to find the <span>$c_{ij}$</span> constants. For <span>$k+1$</span> intervals on <span>$k$</span> knots, there would be <span>$(d+1)(k+1)$</span> constants to choose. When solving for the constants, we need to include equations that assert smoothness across the knots.</p><p>On the other hand, B-splines are functions that are designed, from their definition, to obey smoothness constraints. If constraints are built into the B-spline, we don&#39;t need to include equations to assert those same constraints. There are also fewer constants to choose becasue the final fit will be a sum of the B-splines.</p><p class="math-container">\[y(x) = \sum_j c_j B_j(x).\]</p><p>That means there are exactly as many constants <span>$c_j$</span> as we have degrees of freedom in the problem. If we are fitting with maximally-smooth polynomials, then there are <span>$k+2d$</span> B-splines, total. And, as a neat trick, we don&#39;t need to store the polynomials that define the <span>$B_j(x)$</span>. They are quick to calculate from the knots.</p><p><strong>Prefiltering</strong> is a name for finding the <span>$c_j$</span> values that make a set of B-splines interpolate a set of points. You&#39;re taking data points <span>$(x_p, y_p)$</span> and solving for the <span>$c_j$</span> that make a B-spline-defined polynomial that matches them.</p><h2 id="B-spline-definition-from-its-constraints"><a class="docs-heading-anchor" href="#B-spline-definition-from-its-constraints">B-spline definition from its constraints</a><a id="B-spline-definition-from-its-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#B-spline-definition-from-its-constraints" title="Permalink"></a></h2><p>B-splines are a basis set for polynomial splines on a particular axis, <span>$x_1 &lt; x_2 &lt; x_3 \ldots &lt; x_{k+2}$</span>, with a given set of natural boundary conditions. Because they are a basis set, every allowable polynomial spline with those boundary conditions can be written as a sum of the B-splines for that axis. The set of B-splines reduces the amount of storage needed for a polynomial spline and reduces the computation needed to fit points with a polynomial spline. Now, how could we calculate the polynomial representation of any one of the B-splines for a given axis?</p><p>Let&#39;s compute the polynmial coefficients <span>$c_{ij}$</span> that define a single B-spline on an axis. Start by picking a left-most point, some <span>$x_j$</span>. Then the B-spline will be zero to the left, positive for some number of intervals, say <span>$p$</span> intervals. And then it will be zero to the right of that. We can count the unknown values as <span>$p$</span> intervals of polynomials of degree <span>$d$</span>, so there are <span>$p(d+1)$</span> unknown values. Oddly, we don&#39;t know the number of intervals for this B-spline yet, but continuity conditions will tell us what <span>$p$</span> must be.</p><p>Each continuity condition, at the knot between two intervals, is a constraint on the B-spline, and the sum of the number of constraints must equal the number of unknown polynomial constants, in order for this B-spline to be well-defined. If the multiplicity of each knot is 1, then the number of constraints is <span>$d$</span>. In general, there are <span>$d+1-m_j$</span> constraints at each knot, where <span>$m_j$</span> is knot multiplicity. Over <span>$p$</span> intervals, that makes <span>$(p-1)(d+1) - \sum_j m_j$</span> constraints.</p><p>There are two other kinds of constraints. We use a normalization of the B-spline to define how tall it will be, which is one constraint. We can also add boundary conditions. Let&#39;s first consider the case where the B-spline goes to zero at both sides, with <span>$C^{d-1}$</span> smoothness and has single multiplicity at each knot. That means there are <span>$d$</span> boundary conditions at each side. If we balance our unknowns with our constraints, that will tell us how many intervals wide this B-spline extends.</p><p class="math-container">\[p(d+1)= (p-1)d + 1 + 2d\]</p><p>The solution to this is that <span>$p=d+1$</span>. For a smooth polynomial spline, the B-spline for <span>$d=2$</span> has 3 pieces. For a degree <span>$d=3$</span> B-spline, there are 4 pieces, and there is a more general form that holds true when there is less smoothness.</p><p>We can have up to <span>$2d$</span> boundary conditions, so let&#39;s call that <span>$b\le 2d$</span>. Recall that boundary conditions can be encoded as multiplicity, where a multiplicity of 1 enforces all possible conditions and a multiplicity of <span>$d+1$</span> enforces no boundary conditions at that side.</p><p class="math-container">\[b=2d+2-m_1-m_{p+1}\]</p><p>We can also have knots with higher multiplicity, which reduces the total number of constraints. Note that the <span>$j$</span> in this equation runs over internal knots, so it doesn&#39;t include endpoints and there will be <span>$(p-1)$</span> values of <span>$j$</span>.</p><p class="math-container">\[p(d+1) = (p-1)(d+1) - \sum_{j=2}^{p} m_j + 1 + b\]</p><p>If we simplify this equation, it looks like <span>$p$</span> drops out, but there are <span>$p-1$</span> values of <span>$m_j$</span>, and usually <span>$m_j=1$</span> for all knots. The boundary conditions, as well, are <span>$b\le 2d$</span>.</p><p class="math-container">\[\sum_{j=2}^{p} m_j = b - d\]</p><p>As a check, our simple example has multiplicity 1 and <span>$2d=4$</span> boundary conditions, so <span>$1+1 = 4 - 2$</span>, so math still works. Let&#39;s substitute multiplicity at endpoints for <span>$b$</span>.</p><p class="math-container">\[\sum_{j=2}^{p} m_j = 2d+2-m_1-m_{p+1} - d\]</p><p>This simplifies to a formulat that says that, if you represent your boundary conditions and continuity with B-splines, then every consecutive set of points, where the sum of the multiplicity is <span>$d+2$</span>, is the domain of another B-spline.</p><p class="math-container">\[\sum_{j=1}^{p+1} m_j = d+2\]</p><p>We can walk along the array of multiplicity values in order to generate B-spline polynomials. I&#39;ll write this as code so that you can see that we walk not by vertex but by multiple of the vertices, as though they were written out as an ordered array that had duplicates.</p><pre><code class="language-julia hljs">function every_bspline_on_axis(x::AbstractArray, multiplicity::AbstractArray)
    # -1 because the last point has no B-spline to the right.
    bspline_count = sum(multiplicity) - 1
    bsplines = []
    vertex_index = 1
    multiplicity_index = 1
    while vertex_index &lt;= bspline_count
        push!(bsplines, generate_bspline(x, multiplicity, vertex_index, multiplicity_index))
        multiplicity_index += 1
        if multiplicity_index &gt; multiplicity[vertex_index]
            vertex_index += 1
            multiplicity_index = 1
        end
    end
end</code></pre><p>As a mental check, can a single interval have a B-spline? It has no knots. We see that a B-spline, in this case, is well-defined because there is a solution to <span>$0=b-d$</span>, by setting <span>$b$</span> boundary conditions at the left-hand side <span>$x_l$</span> and right-hand side <span>$x_r$</span>. For the case of degree 2, there are three ways to do this. 1. Set <span>$f(x_l)=0$</span>, <span>$f&#39;(x_l)=0$</span>. 2. Set <span>$f(x_l)=0$</span> and <span>$f(x_r)=0$</span>. 3. Set <span>$f(x_r)=0$</span> and <span>$f&#39;(x_r)=0$</span>. It turns out that <em>every</em> interval has <span>$d+1$</span> splines defined that are nonzero on that interval, no matter what the boundary conditions are.</p><h2 id="How-to-count-B-splines-with-multiplicity"><a class="docs-heading-anchor" href="#How-to-count-B-splines-with-multiplicity">How to count B-splines with multiplicity</a><a id="How-to-count-B-splines-with-multiplicity-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-count-B-splines-with-multiplicity" title="Permalink"></a></h2><p>I&#39;m wondering how to write an algorithm for B-splines that uses multiplicity instead of creating an axis that has repeated values where there are knots. When there is an axis, the answer is simple. If there <span>$k+1$</span> points on the axis, then there are <span>$k+1-m$</span> B-splines. The <span>$i$</span>-th B-spline is at axis point <span>$\tau_i$</span>. It&#39;s straightforward, but this changes when using multiplicity.</p><p>The count of axis points is related to the cumulative multiplicity.</p><p class="math-container">\[M_j = \sum_{i=1}^j m_i\]</p><p>The <span>$i$</span>-th B-spline can be written in terms of multiplicity if we think of it as having <span>$i-1$</span> cumulative multiplicity to the left of it. If we are looking at interval <span>$j$</span>, then <span>$M_j$</span> is the total number of axis points to the left. That means the last B-spline to cover this interval is <span>$M_j$</span> and the first B-spline to cover it will be <span>$M_j-m + 1$</span>, where <span>$m$</span> is the order.</p><h2 id="Calculating-B-splines"><a class="docs-heading-anchor" href="#Calculating-B-splines">Calculating B-splines</a><a id="Calculating-B-splines-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-B-splines" title="Permalink"></a></h2><p>We don&#39;t calculate the polynomial representation of B-splines. We don&#39;t need to, because there are nifty functions that evaluate B-splines without calculating their polynomial constants. The best source for this is Schumaker&#39;s <em>Spline Functions: Basic Theory.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../notation/">« Notation</a><a class="docs-footer-nextpage" href="../testspaces/">Testing B-splines »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 3 October 2022 14:02">Monday 3 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
