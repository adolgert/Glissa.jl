<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Glissa.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://adolgert.github.io/Glissa.jl/reference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Glissa.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../notation/">Notation</a></li><li><a class="tocitem" href="../bsplines/">B-splines</a></li><li><a class="tocitem" href="../testspaces/">Testing B-splines</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li><li><a class="tocitem" href="../projectplan/">Project Plan</a></li><li><a class="tocitem" href="../testplan/">Test Plan</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/adolgert/Glissa.jl/blob/main/docs/src/reference.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><ul><li><a href="#Glissa.DividedDifference"><code>Glissa.DividedDifference</code></a></li><li><a href="#Glissa.NewtonForm"><code>Glissa.NewtonForm</code></a></li><li><a href="#Glissa.NewtonForm-Union{Tuple{T}, Tuple{Vector, Vector{T}}} where T&lt;:Real"><code>Glissa.NewtonForm</code></a></li><li><a href="#Glissa.PiecewisePolynomial"><code>Glissa.PiecewisePolynomial</code></a></li><li><a href="#Glissa.RepeatedIndex"><code>Glissa.RepeatedIndex</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{X}, Tuple{PiecewisePolynomial{X, T}, PiecewisePolynomial{X, T}}} where {X, T}"><code>Base.:*</code></a></li><li><a href="#Base.eltype-Union{Tuple{PiecewisePolynomial{X, T}}, Tuple{T}, Tuple{X}} where {X, T}"><code>Base.eltype</code></a></li><li><a href="#Base.length-Tuple{PiecewisePolynomial}"><code>Base.length</code></a></li><li><a href="#Glissa.bspline_by_matrix!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractVector{Int64}, Any, Any}} where T"><code>Glissa.bspline_by_matrix!</code></a></li><li><a href="#Glissa.bsplineq_recursive-NTuple{5, Any}"><code>Glissa.bsplineq_recursive</code></a></li><li><a href="#Glissa.bsplineq_recursive-NTuple{4, Any}"><code>Glissa.bsplineq_recursive</code></a></li><li><a href="#Glissa.cubic_spline-Union{Tuple{T}, Tuple{X}, Tuple{AbstractVector{X}, AbstractVector{T}, AbstractVector{T}}} where {X&lt;:Real, T&lt;:Real}"><code>Glissa.cubic_spline</code></a></li><li><a href="#Glissa.cubic_spline_coefficients!-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Any, Any}} where T&lt;:Real"><code>Glissa.cubic_spline_coefficients!</code></a></li><li><a href="#Glissa.deboor_swartz_criterion-Union{Tuple{T}, Tuple{T, Any, Any}} where T&lt;:Real"><code>Glissa.deboor_swartz_criterion</code></a></li><li><a href="#Glissa.degree-Tuple{PiecewisePolynomial}"><code>Glissa.degree</code></a></li><li><a href="#Glissa.derivative-Union{Tuple{PiecewisePolynomial{X, T}}, Tuple{T}, Tuple{X}} where {X, T}"><code>Glissa.derivative</code></a></li><li><a href="#Glissa.divdiff-Tuple{Any, Any}"><code>Glissa.divdiff</code></a></li><li><a href="#Glissa.divdiff_repeats-Tuple{Any, Any}"><code>Glissa.divdiff_repeats</code></a></li><li><a href="#Glissa.divided_difference-Tuple{Integer, Integer, AbstractVector, Function, Glissa.DividedDifference}"><code>Glissa.divided_difference</code></a></li><li><a href="#Glissa.divided_difference_explicit-Tuple{Integer, Integer, AbstractVector, Function}"><code>Glissa.divided_difference_explicit</code></a></li><li><a href="#Glissa.dprod-Tuple{Any, Any}"><code>Glissa.dprod</code></a></li><li><a href="#Glissa.evaluate!-Tuple{PiecewisePolynomial, AbstractVector, AbstractVector}"><code>Glissa.evaluate!</code></a></li><li><a href="#Glissa.evaluate_bspline-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray, Any, T}} where T"><code>Glissa.evaluate_bspline</code></a></li><li><a href="#Glissa.generate_normalized_bsplines!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector, Any, Any, T}} where T"><code>Glissa.generate_normalized_bsplines!</code></a></li><li><a href="#Glissa.global_derivatives!-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Any}} where T&lt;:Real"><code>Glissa.global_derivatives!</code></a></li><li><a href="#Glissa.hyman_coefficients!-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Any, Any}} where T&lt;:Real"><code>Glissa.hyman_coefficients!</code></a></li><li><a href="#Glissa.hyman_criterion-Union{Tuple{T}, Tuple{T, Any, Any}} where T&lt;:Real"><code>Glissa.hyman_criterion</code></a></li><li><a href="#Glissa.integral_in_interval-Union{Tuple{T}, Tuple{X}, Tuple{A}, Tuple{PiecewisePolynomial{X, T}, Any, A}} where {A&lt;:Real, X, T}"><code>Glissa.integral_in_interval</code></a></li><li><a href="#Glissa.integrate-Union{Tuple{A}, Tuple{PiecewisePolynomial, A, A}} where A&lt;:Real"><code>Glissa.integrate</code></a></li><li><a href="#Glissa.normalized_bspline-Union{Tuple{T}, Tuple{Integer, Integer, Vector{T}, T}} where T&lt;:Real"><code>Glissa.normalized_bspline</code></a></li><li><a href="#Glissa.order-Tuple{PiecewisePolynomial}"><code>Glissa.order</code></a></li><li><a href="#Glissa.piecewise_representation!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractVector}} where T"><code>Glissa.piecewise_representation!</code></a></li><li><a href="#Glissa.polyspline_constraints!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractVector{Int64}, Any}} where T"><code>Glissa.polyspline_constraints!</code></a></li><li><a href="#Glissa.project_to_monotonicity!-Tuple{Any, Any, Any}"><code>Glissa.project_to_monotonicity!</code></a></li><li><a href="#Glissa.reduce_axis-Tuple{AbstractVector, Any, Any}"><code>Glissa.reduce_axis</code></a></li><li><a href="#Glissa.single_polynomial-Union{Tuple{X}, Tuple{T}, Tuple{Vector{X}, Vector{T}}} where {T&lt;:Real, X&lt;:Real}"><code>Glissa.single_polynomial</code></a></li><li><a href="#Glissa.splinen_divided-NTuple{4, Any}"><code>Glissa.splinen_divided</code></a></li><li><a href="#Glissa.splineq_divided-NTuple{4, Any}"><code>Glissa.splineq_divided</code></a></li><li><a href="#Glissa.truncated-NTuple{4, Any}"><code>Glissa.truncated</code></a></li><li><a href="#Glissa.truncated-Tuple{Any, Any, Any}"><code>Glissa.truncated</code></a></li><li><a href="#Glissa.vandermonde_determinant_repeats-Tuple{Any, Any}"><code>Glissa.vandermonde_determinant_repeats</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Glissa.DividedDifference" href="#Glissa.DividedDifference"><code>Glissa.DividedDifference</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A recursive implementation of divided differences.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/divided_differences.jl#L124-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.NewtonForm" href="#Glissa.NewtonForm"><code>Glissa.NewtonForm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Newton form for an interpolating polynomial represents <span>$f(x)$</span> at points <span>$\tau$</span> by a sum.</p><p><span>$\sum_{i=0}^n f[x_0,\ldots,x_i]\prod_{j=0}^{i-1}(x-x_j)$</span></p><p>Here, the <code>a</code> are the divided differences and <span>$\tau$</span> are the <code>x[j]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/newton_form.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.NewtonForm-Union{Tuple{T}, Tuple{Vector, Vector{T}}} where T&lt;:Real" href="#Glissa.NewtonForm-Union{Tuple{T}, Tuple{Vector, Vector{T}}} where T&lt;:Real"><code>Glissa.NewtonForm</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a NewtonForm. From Conte and deBoor 1980, Eqn. 4.8.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/newton_form.jl#L15-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.PiecewisePolynomial" href="#Glissa.PiecewisePolynomial"><code>Glissa.PiecewisePolynomial</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This is a piecewise polynomial. It has N+1 points on the abcissa, <span>$\tau$</span>. It has N cubic interpolants in <code>c</code>, which is size 4 x N for a cubic spline. At each interval, the polynomial is in Horner Form,</p><p><span>$P_i(x) = c_{1,i} + c_{2,i}(x-x_i) + c_{3,i}(x-x_i)^2 + c_{4,i}(x-x_i)^3$</span></p><p>This spline has one type for the abcissa and one for the ordinate coefficients. It should be the case that one(T) * one(X) is of type T.</p><p>This can be a spline of another order. It&#39;s just a matter of the dimensions of the coefficient array, <code>c</code>. You would evaluate this with <code>evalpoly(x-τ[i], c[1:end, i])</code>, where <code>i</code> is the interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/piecewise.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.RepeatedIndex" href="#Glissa.RepeatedIndex"><code>Glissa.RepeatedIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RepeatedIndex(multiple::AbstractVector)</code></pre><p>Uses a multiplicity vector to present a vector as having repeated elements. If a vector is length 3, and <code>multiple</code> is <code>[2, 1, 3]</code><code>, then this index will return the values</code>[1, 1, 2, 3, 3, 3]`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/axis_handling.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{X}, Tuple{PiecewisePolynomial{X, T}, PiecewisePolynomial{X, T}}} where {X, T}" href="#Base.:*-Union{Tuple{T}, Tuple{X}, Tuple{PiecewisePolynomial{X, T}, PiecewisePolynomial{X, T}}} where {X, T}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Multiply two splines of order <code>m1</code> and <code>m2</code> to get a spline of order <code>m1+m2</code>. This only works if the two splines have the same abcissa.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/piecewise.jl#L116-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Union{Tuple{PiecewisePolynomial{X, T}}, Tuple{T}, Tuple{X}} where {X, T}" href="#Base.eltype-Union{Tuple{PiecewisePolynomial{X, T}}, Tuple{T}, Tuple{X}} where {X, T}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Type of the polynomial constants.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/piecewise.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{PiecewisePolynomial}" href="#Base.length-Tuple{PiecewisePolynomial}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Number of vertices in axis, which is 1 + number of intervals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/piecewise.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.bspline_by_matrix!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractVector{Int64}, Any, Any}} where T" href="#Glissa.bspline_by_matrix!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractVector{Int64}, Any, Any}} where T"><code>Glissa.bspline_by_matrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate coefficients of a b-spline of order m, degree m-1 by sending an axis of length m+1 and a coefficient matrix of size mxm, into which are written columns of coefficients for the polynomial of each interval. If you want a b-spline on a subset of an axis, use an array view for inputs. This is the least efficient way to calculate these coefficients, but it makes explicit the continuity conditions that lead to a solution. <code>i</code> is the index of the leftmost point, counting points by their multiplicity, so a point with multiplicity of 3 is three points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/bsplineconstraints.jl#L87-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.bsplineq_recursive-NTuple{4, Any}" href="#Glissa.bsplineq_recursive-NTuple{4, Any}"><code>Glissa.bsplineq_recursive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bsplineq(axis, order, index, x)</code></pre><p>This is the <span>$Q_i^m(x)$</span> B-spline, which is normalized to <span>$1/m$</span>. Here is is defined by recursion. Needs <code>length(axis) ≤ index + order</code>. The <code>order</code> is 1 or greater.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/recursive.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.bsplineq_recursive-NTuple{5, Any}" href="#Glissa.bsplineq_recursive-NTuple{5, Any}"><code>Glissa.bsplineq_recursive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bsplineq(axis, order, index, x, nth_derivative)</code></pre><p>This is the <span>$Q_i^m(x)$</span> B-spline, which is normalized to <span>$1/m$</span>. Here is is defined by recursion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/recursive.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.cubic_spline-Union{Tuple{T}, Tuple{X}, Tuple{AbstractVector{X}, AbstractVector{T}, AbstractVector{T}}} where {X&lt;:Real, T&lt;:Real}" href="#Glissa.cubic_spline-Union{Tuple{T}, Tuple{X}, Tuple{AbstractVector{X}, AbstractVector{T}, AbstractVector{T}}} where {X&lt;:Real, T&lt;:Real}"><code>Glissa.cubic_spline</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates a cubic spline on abcissa <code>τ</code> with values <code>f</code> and endpoint slopes equal to <code>fp[1]</code> and <code>fp[2]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/cubic_spline.jl#L199-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.cubic_spline_coefficients!-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Any, Any}} where T&lt;:Real" href="#Glissa.cubic_spline_coefficients!-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Any, Any}} where T&lt;:Real"><code>Glissa.cubic_spline_coefficients!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given an abcissa, τ, of length N+1 values f of length N+1, and derivatives s of length N+1, this computes the 4xN matrix c of cubic coefficients. Conte and deBoor Eq. 4.55</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/cubic_spline.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.deboor_swartz_criterion-Union{Tuple{T}, Tuple{T, Any, Any}} where T&lt;:Real" href="#Glissa.deboor_swartz_criterion-Union{Tuple{T}, Tuple{T, Any, Any}} where T&lt;:Real"><code>Glissa.deboor_swartz_criterion</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot;Accurate Monotonicity Preserving Cubic Interpolation&quot; by James M Hyman. 1983.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/cubic_spline.jl#L76-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.degree-Tuple{PiecewisePolynomial}" href="#Glissa.degree-Tuple{PiecewisePolynomial}"><code>Glissa.degree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Polynomial degree, so 2 for <span>$x^2$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/piecewise.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.derivative-Union{Tuple{PiecewisePolynomial{X, T}}, Tuple{T}, Tuple{X}} where {X, T}" href="#Glissa.derivative-Union{Tuple{PiecewisePolynomial{X, T}}, Tuple{T}, Tuple{X}} where {X, T}"><code>Glissa.derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a spline, create a new spline that is its derivative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/piecewise.jl#L101-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.divdiff-Tuple{Any, Any}" href="#Glissa.divdiff-Tuple{Any, Any}"><code>Glissa.divdiff</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Definition 2.49 of divided differences from Schumaker. Eqn 2.86.</p><blockquote><p>axis = 0:5 f(x) = 2.3 + 0.5*x^2 - x^3 divdiff(axis, f)</p></blockquote></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/divided_differences.jl#L109-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.divdiff_repeats-Tuple{Any, Any}" href="#Glissa.divdiff_repeats-Tuple{Any, Any}"><code>Glissa.divdiff_repeats</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Divided differences that allow for derivatives. Schumaker page 46-7, eqn 2.89.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/divided_differences.jl#L83-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.divided_difference-Tuple{Integer, Integer, AbstractVector, Function, Glissa.DividedDifference}" href="#Glissa.divided_difference-Tuple{Integer, Integer, AbstractVector, Function, Glissa.DividedDifference}"><code>Glissa.divided_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate divided differences of a function f at points τ, using recursion.</p><p class="math-container">\[[\tau_i, \tau_{i+1},\ldots,\tau_j]f\]</p><p>This calculates the divided difference from τ<em>i to τ</em>j. The <code>dd</code> is a memoization. If any knots are equal, define <code>f(x,n)</code> where <code>n</code> is how many times to take the derivative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/divided_differences.jl#L143-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.divided_difference_explicit-Tuple{Integer, Integer, AbstractVector, Function}" href="#Glissa.divided_difference_explicit-Tuple{Integer, Integer, AbstractVector, Function}"><code>Glissa.divided_difference_explicit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This explicit divided difference applies only when the axis is distinct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/divided_differences.jl#L174-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.dprod-Tuple{Any, Any}" href="#Glissa.dprod-Tuple{Any, Any}"><code>Glissa.dprod</code></a> — <span class="docstring-category">Method</span></header><section><div><p><span>$a(a+1)(a+2)\cdots(b-1)b$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/bsplineconstraints.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.evaluate!-Tuple{PiecewisePolynomial, AbstractVector, AbstractVector}" href="#Glissa.evaluate!-Tuple{PiecewisePolynomial, AbstractVector, AbstractVector}"><code>Glissa.evaluate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate a piecewise polynomial at a series of <code>x</code> values and write into <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/piecewise.jl#L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.evaluate_bspline-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray, Any, T}} where T" href="#Glissa.evaluate_bspline-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray, Any, T}} where T"><code>Glissa.evaluate_bspline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate_bspline(c::AbstractArray{T}, y::AbstractArray, m, x::T) where {T}</code></pre><p>Evaluate B-spline with coefficients <code>c</code> on axis <code>y</code> of order <code>m</code> at <code>x</code>. This is Algorithm 5.8 from Schumaker.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/bspline.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.generate_normalized_bsplines!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector, Any, Any, T}} where T" href="#Glissa.generate_normalized_bsplines!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector, Any, Any, T}} where T"><code>Glissa.generate_normalized_bsplines!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_normalized_bsplines!(N::AbstractVector{T}, y::AbstractVector, l, m, x::T) where {T}</code></pre><p>Given x in <span>$[y_l, y_l+1)$</span> to generate <span>$N^m_{l+1-m}(x)$</span> to <span>$N_l^m(x).$</span> <code>y</code> is the axis. <code>m</code> is the order of the b-spline. The <code>l</code> is found by a search of the axis, and the axis can have repeated elements. This algorithm applies to axis intervals where <span>$y_{l+1} &gt; y_l$</span>, not equal to it. That tells us how to number the expansion coefficients, <code>c</code>. It&#39;s Algorithm 5.5 from Schumaker&#39;s book.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/bspline.jl#L7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.global_derivatives!-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Any}} where T&lt;:Real" href="#Glissa.global_derivatives!-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Any}} where T&lt;:Real"><code>Glissa.global_derivatives!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>τ are the abcissa from 1 to N+1. f are the known values of length N+1. fp_bounds are derivatives at the first and last endpoint. fp is the output, of length N + 1. This is from Conte and deBoor Sec. 4.8, Eq. 4.60. The equation is this, with <span>$i$</span> running from 2 to N.</p><p><span>$(\Delta x_i) s_{i-1}+2(\Delta x_{i-1}+\Delta x_i)s_i +(\Delta x_{i-1}s_{i+1}) = 3(f[x_{i-1},x_i]\Delta x_i+f[x_i,x_{i+1}]\Delta x_{i-1})$</span></p><p>Here, <span>$\Delta x_i = x_{i+1} -x{i}$</span> and</p><p><span>$f[x_i,x_{i+1}] = \frac{f[x_{i+1}] - f[x_i]}{x_{i+1}-x_i}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/cubic_spline.jl#L6-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.hyman_coefficients!-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Any, Any}} where T&lt;:Real" href="#Glissa.hyman_coefficients!-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Any, Any}} where T&lt;:Real"><code>Glissa.hyman_coefficients!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This is how splinefun sets the coefficients. Seems to have the same result as the code above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/cubic_spline.jl#L137-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.hyman_criterion-Union{Tuple{T}, Tuple{T, Any, Any}} where T&lt;:Real" href="#Glissa.hyman_criterion-Union{Tuple{T}, Tuple{T, Any, Any}} where T&lt;:Real"><code>Glissa.hyman_criterion</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This comes from Hyman&#39;s paper but is modified by the R implementation of splinefun, which Simon Wood wrote. I didn&#39;t understand from the paper the exact structure of decisions to take in the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/cubic_spline.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.integral_in_interval-Union{Tuple{T}, Tuple{X}, Tuple{A}, Tuple{PiecewisePolynomial{X, T}, Any, A}} where {A&lt;:Real, X, T}" href="#Glissa.integral_in_interval-Union{Tuple{T}, Tuple{X}, Tuple{A}, Tuple{PiecewisePolynomial{X, T}, Any, A}} where {A&lt;:Real, X, T}"><code>Glissa.integral_in_interval</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Integrate a spline from a knot at <code>i</code> to the value <code>x</code>.</p><p><strong>(((A(1/4)<em>cs.c[4, i] * Δ + A(1/3)</em>cs.c[3, i]) * Δ + A(1/2)<em>cs.c[2, i]) * Δ + cs.c[1, i])</em>Δ</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/piecewise.jl#L62-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.integrate-Union{Tuple{A}, Tuple{PiecewisePolynomial, A, A}} where A&lt;:Real" href="#Glissa.integrate-Union{Tuple{A}, Tuple{PiecewisePolynomial, A, A}} where A&lt;:Real"><code>Glissa.integrate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Integrate a spline from <code>x1</code> to <code>x2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/piecewise.jl#L82-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.normalized_bspline-Union{Tuple{T}, Tuple{Integer, Integer, Vector{T}, T}} where T&lt;:Real" href="#Glissa.normalized_bspline-Union{Tuple{T}, Tuple{Integer, Integer, Vector{T}, T}} where T&lt;:Real"><code>Glissa.normalized_bspline</code></a> — <span class="docstring-category">Method</span></header><section><div><p>An explicit representation of the normalized B-spline.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/truncated.jl#L34-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.order-Tuple{PiecewisePolynomial}" href="#Glissa.order-Tuple{PiecewisePolynomial}"><code>Glissa.order</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The order is one plus the degree of the polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/piecewise.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.piecewise_representation!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractVector}} where T" href="#Glissa.piecewise_representation!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractVector}} where T"><code>Glissa.piecewise_representation!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Algorithm 5.15: Construct a piecewise polynomial representation of a polynomial spline that is represented by spline coefficients. This converts out of B-splines to the polynomial representation. If there are more than about 2 evaluations of each spline interval, this can be more efficient. Each spline <span>$i$</span> is represented by a polynomial of the form</p><p><span>$s_i(x)= \sum_{j=1}^m w_{ji} (x - \tau_i)^{j-1}$</span></p><p>where <span>$w_{ij}$</span> are polynomial constants for the <code>i</code>th B-spline.</p><p>Initialize <code>w = zeros(T, m, n)</code> where <code>n</code> is the number of B-spline coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/schumaker.jl#L40-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.polyspline_constraints!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractVector{Int64}, Any}} where T" href="#Glissa.polyspline_constraints!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractVector{Int64}, Any}} where T"><code>Glissa.polyspline_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This reads a list of multiplicities and converts that into a matrix that represents the constraints indicated by those multiplicites. The resulting matrix defines the space of the given polynomial spline on this axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/bsplineconstraints.jl#L189-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.project_to_monotonicity!-Tuple{Any, Any, Any}" href="#Glissa.project_to_monotonicity!-Tuple{Any, Any, Any}"><code>Glissa.project_to_monotonicity!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Uses Hyman piecewise monotonicity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/cubic_spline.jl#L116-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.reduce_axis-Tuple{AbstractVector, Any, Any}" href="#Glissa.reduce_axis-Tuple{AbstractVector, Any, Any}"><code>Glissa.reduce_axis</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This extracts from a multiplicity vector the support for the <code>i</code>th B-spline. There is an axis where <code>length(axis)=length(multiplicity)</code>. This axis will, in general, support multiple B-splines. This function returns a sub-range of that axis and a new multiplicity vector, the same length as that sub-range. It will be the exact support for the <code>i</code>th B-spline of order <code>order</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/bsplineconstraints.jl#L168-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.single_polynomial-Union{Tuple{X}, Tuple{T}, Tuple{Vector{X}, Vector{T}}} where {T&lt;:Real, X&lt;:Real}" href="#Glissa.single_polynomial-Union{Tuple{X}, Tuple{T}, Tuple{Vector{X}, Vector{T}}} where {T&lt;:Real, X&lt;:Real}"><code>Glissa.single_polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given an axis <code>τ</code> and values <code>f</code> on that axis, return a polynomial <code>y</code> such that</p><p><span>$y(τ[i]) = f[i]$</span></p><p>Construct a polynomial that interpolates a function, using polynomials with zeroes. This should match the constructor above. It comes from deBoor equation 4.2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/newton_form.jl#L41-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.splinen_divided-NTuple{4, Any}" href="#Glissa.splinen_divided-NTuple{4, Any}"><code>Glissa.splinen_divided</code></a> — <span class="docstring-category">Method</span></header><section><div><p>An N version of the B-spline on an axis y, order m, index i, at x. This version is defined using divided differences.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/divided_differences.jl#L214-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.splineq_divided-NTuple{4, Any}" href="#Glissa.splineq_divided-NTuple{4, Any}"><code>Glissa.splineq_divided</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A Q version of the B-spline on an axis y, order m, index i, at x. This version is defined using divided differences.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/divided_differences.jl#L199-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.truncated-NTuple{4, Any}" href="#Glissa.truncated-NTuple{4, Any}"><code>Glissa.truncated</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A truncated function with a derivative with respect to <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/truncated.jl#L17-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.truncated-Tuple{Any, Any, Any}" href="#Glissa.truncated-Tuple{Any, Any, Any}"><code>Glissa.truncated</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This is the truncated function that defines the Q B-spline.</p><p class="math-container">\[(x - c)_{+}^k\]</p><p>It&#39;s only defined when <span>$x &gt; c$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/truncated.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Glissa.vandermonde_determinant_repeats-Tuple{Any, Any}" href="#Glissa.vandermonde_determinant_repeats-Tuple{Any, Any}"><code>Glissa.vandermonde_determinant_repeats</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The equation 2.67 in Schumaker is hard to understand. It reads, exactly,</p><p class="math-container">\[V(t_1,\ldots,t_m)=\prod_{1\le i&lt;j\le d}(\tau_j-\tau_i)^{l_jl_i} \prod_{i=1}^d\prod_{\nu=1}^{l_i-1}\nu!\]</p><p>The LHS goes to <span>$m$</span> to count the total length of the axis. The RHS uses <span>$d$</span> which is the number of unique values. I have a hard time believing it&#39;s a product of factorials at the end. Maybe he wanted just a single product over the factorial?</p><p class="math-container">\[\prod_{i=1}^d (\l_i-1)!\]</p><p>Let&#39;s check it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Glissa.jl/blob/4bf9f7fd85efffc660aaa8f403a2f1c1e3e09ae0/src/divided_differences.jl#L53-L65">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../testspaces/">« Testing B-splines</a><a class="docs-footer-nextpage" href="../projectplan/">Project Plan »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 3 October 2022 14:02">Monday 3 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
