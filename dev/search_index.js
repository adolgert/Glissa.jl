var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Glissa","category":"page"},{"location":"#Glissa","page":"Home","title":"Glissa","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Glissa.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Glissa]","category":"page"},{"location":"#Glissa.CubicSpline","page":"Home","title":"Glissa.CubicSpline","text":"This is a traditional cubic spline. It has N+1 points on the abcissa, tau. It has N cubic interpolants in c, which is size 4 x N. At each interval, the polynomial is in Horner Form,\n\nP_i(x) = c_1i + c_2i(x-x_i) + c_3i(x-x_i)^2 + c_4i(x-x_i)^3\n\nThis spline has one type for the abcissa and one for the ordinate coefficients. It should be the case that one(T) * one(X) is of type T.\n\nThis can be a spline of another order. It's just a matter of the dimensions of the coefficient array, c.\n\n\n\n\n\n","category":"type"},{"location":"#Glissa.DividedDifference","page":"Home","title":"Glissa.DividedDifference","text":"A recursive implementation of divided differences.\n\n\n\n\n\n","category":"type"},{"location":"#Glissa.NewtonForm","page":"Home","title":"Glissa.NewtonForm","text":"The Newton form for an interpolating polynomial represents f(x) at points tau` by a sum.\n\n``\\sum{i=0}^n f[x0,\\ldots,xi]\\prod{j=0}^{i-1}(x-x_j)\n\nHere, the a are the divided differences and tau are the x[j].\n\n\n\n\n\n","category":"type"},{"location":"#Glissa.NewtonForm-Union{Tuple{T}, Tuple{Vector{T} where T, Vector{T}}} where T<:Real","page":"Home","title":"Glissa.NewtonForm","text":"Construct a NewtonForm. From Conte and deBoor 1980, Eqn. 4.8.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{X}, Tuple{CubicSpline{X, T}, CubicSpline{X, T}}} where {X, T}","page":"Home","title":"Base.:*","text":"Multiply two splines of order m1 and m2 to get a spline of order m1+m2. This only works if the two splines have the same abcissa.\n\n\n\n\n\n","category":"method"},{"location":"#Glissa.cubic_spline_coefficients!-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Any, Any}} where T<:Real","page":"Home","title":"Glissa.cubic_spline_coefficients!","text":"Given an abcissa, τ, of length N+1 values f of length N+1, and derivatives s of length N+1, this computes the 4xN matrix c of cubic coefficients. Conte and deBoor Eq. 4.55\n\n\n\n\n\n","category":"method"},{"location":"#Glissa.deboor_swartz_criterion-Union{Tuple{T}, Tuple{T, Any, Any}} where T<:Real","page":"Home","title":"Glissa.deboor_swartz_criterion","text":"\"Accurate Monotonicity Preserving Cubic Interpolation\" by James M Hyman. 1983.\n\n\n\n\n\n","category":"method"},{"location":"#Glissa.derivative-Union{Tuple{CubicSpline{X, T}}, Tuple{T}, Tuple{X}} where {X, T}","page":"Home","title":"Glissa.derivative","text":"Given a spline, create a new spline that is its derivative.\n\n\n\n\n\n","category":"method"},{"location":"#Glissa.divided_difference-Tuple{Integer, Integer, Vector{T} where T, Vector{T} where T, Glissa.DividedDifference}","page":"Home","title":"Glissa.divided_difference","text":"Calculate divided differences of a function f at points τ. This calculates the divided difference from τi to τj. The dd is a memoization.\n\n\n\n\n\n","category":"method"},{"location":"#Glissa.global_derivatives!-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Any}} where T<:Real","page":"Home","title":"Glissa.global_derivatives!","text":"τ are the abcissa from 1 to N+1. f are the known values of length N+1. fp_bounds are derivatives at the first and last endpoint. fp is the output, of length N + 1. This is from Conte and deBoor Sec. 4.8, Eq. 4.60. The equation is this, with i running from 2 to N.\n\n(Delta x_i) s_i-1+2(Delta x_i-1+Delta x_i)s_i +(Delta x_i-1s_i+1) = 3(fx_i-1x_iDelta x_i+fx_ix_i+1Delta x_i-1)\n\nHere, Delta x_i = x_i+1 -xi and\n\nfx_ix_i+1 = fracfx_i+1 - fx_ix_i+1-x_i\n\n\n\n\n\n","category":"method"},{"location":"#Glissa.horner_in_interval-Union{Tuple{T}, Tuple{X}, Tuple{CubicSpline{X, T}, Any, Any}} where {X, T}","page":"Home","title":"Glissa.horner_in_interval","text":"((cs.c[4, i] * Δ + cs.c[3, i]) * Δ + cs.c[2, i]) * Δ + cs.c[1, i]\n\n\n\n\n\n","category":"method"},{"location":"#Glissa.hyman_coefficients!-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Any, Any}} where T<:Real","page":"Home","title":"Glissa.hyman_coefficients!","text":"This is how splinefun sets the coefficients. Seems to have the same result as the code above.\n\n\n\n\n\n","category":"method"},{"location":"#Glissa.hyman_criterion-Union{Tuple{T}, Tuple{T, Any, Any}} where T<:Real","page":"Home","title":"Glissa.hyman_criterion","text":"This comes from Hyman's paper but is modified by the R implementation of splinefun, which Simon Wood wrote. I didn't understand from the paper the exact structure of decisions to take in the function.\n\n\n\n\n\n","category":"method"},{"location":"#Glissa.integral_in_interval-Union{Tuple{T}, Tuple{X}, Tuple{A}, Tuple{CubicSpline{X, T}, Any, A}} where {A<:Real, X, T}","page":"Home","title":"Glissa.integral_in_interval","text":"Integrate a spline from a knot at i to the value x.\n\n(((A(1/4)cs.c[4, i] * Δ + A(1/3)cs.c[3, i]) * Δ + A(1/2)cs.c[2, i]) * Δ + cs.c[1, i])Δ\n\n\n\n\n\n","category":"method"},{"location":"#Glissa.integrate-Union{Tuple{A}, Tuple{CubicSpline, A, A}} where A<:Real","page":"Home","title":"Glissa.integrate","text":"Integrate a spline from x1 to x2.\n\n\n\n\n\n","category":"method"},{"location":"#Glissa.normalized_bspline-Union{Tuple{T}, Tuple{Integer, Integer, Vector{T}, T}} where T<:Real","page":"Home","title":"Glissa.normalized_bspline","text":"An explicit representation of the normalized B-spline.\n\n\n\n\n\n","category":"method"},{"location":"#Glissa.project_to_monotonicity!-Tuple{Any, Any, Any}","page":"Home","title":"Glissa.project_to_monotonicity!","text":"Uses Hyman piecewise monotonicity.\n\n\n\n\n\n","category":"method"},{"location":"#Glissa.single_polynomial-Union{Tuple{X}, Tuple{T}, Tuple{Vector{X}, Vector{T}}} where {T<:Real, X<:Real}","page":"Home","title":"Glissa.single_polynomial","text":"Construct a polynomial that interpolates a function, using polynomials with zeroes. This should match the constructor above. It comes from deBoor equation 4.2.\n\n\n\n\n\n","category":"method"}]
}
