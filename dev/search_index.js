var documenterSearchIndex = {"docs":
[{"location":"projectplan/#Project-Plan","page":"Project Plan","title":"Project Plan","text":"","category":"section"},{"location":"projectplan/#Goal","page":"Project Plan","title":"Goal","text":"","category":"section"},{"location":"projectplan/","page":"Project Plan","title":"Project Plan","text":"I'd like to expand the capabilities of Interpolations.jl so that it supports","category":"page"},{"location":"projectplan/","page":"Project Plan","title":"Project Plan","text":"a) Non-uniform interpolation","category":"page"},{"location":"projectplan/","page":"Project Plan","title":"Project Plan","text":"b) Varying smoothness of interpolant, also known as multiple knots.","category":"page"},{"location":"projectplan/#Scope","page":"Project Plan","title":"Scope","text":"","category":"section"},{"location":"projectplan/","page":"Project Plan","title":"Project Plan","text":"This will have all of the B-spline functionality that a professional library should have, including derivatives, integrals, and conversion to polynomial pieces.\nThis is not a standalone fitting library.\nThis will not make its own user interface. It will be implementations of core algorithms.\nThis will include statements of the math setup for each function but not derivations.","category":"page"},{"location":"projectplan/#Code-Qualities","page":"Project Plan","title":"Code Qualities","text":"","category":"section"},{"location":"projectplan/","page":"Project Plan","title":"Project Plan","text":"This code should be raw tools with which to build a different implementation, so that changes the usual code qualities.","category":"page"},{"location":"projectplan/","page":"Project Plan","title":"Project Plan","text":"Mutability will help these functions be adaptable to other uses, which is a main goal.\nTestability is high on this list, because these routines are meant for use by another library.\nUsability is a lower factor here than usual because this should work underneath another library's interface. The main usability concern is resource usage. So don't dictate the creation of buffers and do check for type stability.\nReliability isn't as much a problem because the problem domain is very controlled.\nSecurity, this might make buffer overruns.","category":"page"},{"location":"projectplan/#Threats","page":"Project Plan","title":"Threats","text":"","category":"section"},{"location":"projectplan/","page":"Project Plan","title":"Project Plan","text":"Redoing other work. - I did a survey of the spline libraries, and it looks like people made pieces of B-splines in order to serve particular purposes, but I don't see implementations that deal with the ugly non-uniform, multiple-knot stuff.\nCan't figure out how to use it in Interpolations.jl. - Ask for help here. And do a pre-read of the package to understand the structure as much as I can.\nCode is buggy. - I'll test the heck out of this.\nCode is incorrect. - Because there aren't a lot of implementations that include non-uniform, multiple-knot versions, there isn't a lot of comparison. Can ameliorate this by making multiple internal versions for testing. Also, use the well-known books: Schumaker, Dierckx, Conte and de Boor.\nPackage loads slowly because it is larger than necessary. - I'm putting multiple versions into the same package, so that's excess code to compile. That's OK here because we'll pull out functionality, and that main functionality has very few dependencies.","category":"page"},{"location":"projectplan/#External-Dependencies","page":"Project Plan","title":"External Dependencies","text":"","category":"section"},{"location":"projectplan/","page":"Project Plan","title":"Project Plan","text":"We'll have lots of dependencies that are for testing.","category":"page"},{"location":"projectplan/","page":"Project Plan","title":"Project Plan","text":"ForwardDiff.jl. This gives simple derivatives, so you don't have to think about it.\nSymbolics.jl - Such an excellent way to see whether two algorithms agree exactly. Pass a symbolic value in, and define the axis with rationals. Then the results should be exactly the same on the way out.\nRCall.jl, PyCall.jl - Compare against R and Python libraries.\nLinearAlgebra.jl - This is a core library. OK to use that liberally.\nRandom, Distributions.jl - These generate sets of tests quickly.","category":"page"},{"location":"testplan/#Test-Plan","page":"Test Plan","title":"Test Plan","text":"","category":"section"},{"location":"testplan/","page":"Test Plan","title":"Test Plan","text":"This package provides non-uniform and uniform B-spline implementations. The standard methods, from Schumaker, Dierkx, and back to Conte and de Boor, are complicated enough, but we might implement signal processing techniques, as well. All need to be checked.","category":"page"},{"location":"testplan/#Risks-for-Testing","page":"Test Plan","title":"Risks for Testing","text":"","category":"section"},{"location":"testplan/","page":"Test Plan","title":"Test Plan","text":"This isn't a list of project risks but of where I see complexity in the code.","category":"page"},{"location":"testplan/","page":"Test Plan","title":"Test Plan","text":"Differences in notation among source material mean I hook together functions incorrectly.\nOff-by-one errors coming from translation among C, Fortran, and Julia.\nThere could be domain problems when knots are very close together. I don't know how well-tested this published code is. Often, professional solutions don't look like the published ones, and the published ones lead to floating-point exceptions.\nThere could be interactions among types in Julia, that aren't anticipated. For instance, using Rationals with Floats, or Floats of differing precision.\nCurrent usage doesn't exercise the code enough to see errors, for instance the use of non-uniform axes that also have inhomogenous multiplicity.\nResource usage as a non-functional error, meaning there are too many memory allocations or a mistake in choosing template parameters, leading to slow code.\nMisuse of Julia features, like custom indexing, that leads to calling functions incorrectly.","category":"page"},{"location":"testplan/#Addressing-risk-outside-of-testing","page":"Test Plan","title":"Addressing risk outside of testing","text":"","category":"section"},{"location":"testplan/","page":"Test Plan","title":"Test Plan","text":"Use a single notation. I'll record notation in the documentation, as a separate document, and then translate each algorithm, from different sources, to use that notation. It's painstaking but important.","category":"page"},{"location":"testplan/","page":"Test Plan","title":"Test Plan","text":"Include testing code in the main library. This is a way to make it easier to write tests when there is a lot of support code. By \"testing code,\" I mean alternative versions of functions with which to compare other functions, so these aren't @test invocations bug supporting functions. I wish there were, in general, a way to designate part of a library as not autoloaded in a package, but we'll make do.","category":"page"},{"location":"testplan/#Broad-Test-methods","page":"Test Plan","title":"Broad Test methods","text":"","category":"section"},{"location":"testplan/","page":"Test Plan","title":"Test Plan","text":"Comparison\nMultiple implementations\nTwo functions with same input and output.\nImplementation in another Julia library, like Dierckx.\nImplementation in R or Python.\nMultiple stages of derivation of the equations\nSymbolic calculation\nPolynomial-based calculation\nB-spline-based calculation\nPublished values\nWikipedia\nGradshteyn and Ryzhik\nTheoretically tractable\nCheck B-spline invariants, such as the integral of the B-spline, its completeness over an interval.\nPolynomial fit to a polynomially-generated set of data.\nConstruct B-spline, convert to polynomial, then convert back.\nLimiting forms\nA non-uniform method on a uniform grid should agree with the uniform solution.\nIncreasing number of knots should approximate solution at a known rate.\nScaling tests\nShift and scale of whole axis should shift and scale the functions on that axis.\nNumerical checks\nTest with Float, BigFloat, Rational, Int.\nCheck for type stability.\nCheck that this can be auto-differentiated.\nLook for divide-by-zero. That can happen here for close knots.\nMatrix solution stability. Can use numerical checks. We'll work with recommended solutions from literature, but the numerical checks of stability are reassurance about which code is ready to use and which isn't.","category":"page"},{"location":"testplan/#Test-Harness-Specifics","page":"Test Plan","title":"Test Harness Specifics","text":"","category":"section"},{"location":"testplan/#Knot-multiplicity-translation","page":"Test Plan","title":"Knot multiplicity translation","text":"","category":"section"},{"location":"testplan/","page":"Test Plan","title":"Test Plan","text":"There are two ways to specify an axis. One repeats knots.","category":"page"},{"location":"testplan/","page":"Test Plan","title":"Test Plan","text":"(x_1 x_1 x_2 x_2ldotsx_kx_k+1)","category":"page"},{"location":"testplan/","page":"Test Plan","title":"Test Plan","text":"The other uses an integer vector of multiplicities to indicate consecutive, identical knot values.","category":"page"},{"location":"testplan/","page":"Test Plan","title":"Test Plan","text":"(22ldots11)","category":"page"},{"location":"testplan/","page":"Test Plan","title":"Test Plan","text":"I'll need to translate from one to the other and back.","category":"page"},{"location":"testplan/#Polynomial-versus-Spline","page":"Test Plan","title":"Polynomial versus Spline","text":"","category":"section"},{"location":"testplan/","page":"Test Plan","title":"Test Plan","text":"The library rests on a few data structures, among which tests will need to translate.","category":"page"},{"location":"testplan/","page":"Test Plan","title":"Test Plan","text":"The B-spline representation, which is a set of B-spline coefficients. a. An axis, Float64[] (or other type, but it's a vector. That's the point.). b. Coefficients, Float64[].\nThe polynomial pieces representation, which is a set of polynomials defined on consecutive intervals. a. An axis, Float64[]. b. Polynomial constants, Array{Float64}(coefficient order, interval count).\nA polynomial representation of the B-splines. This isn't standard. It would be an array of polynomial pieces on each interval. If the order is m, then there are m B-splines at each interval. a. An axis, Float64[]. b. Polynomials for all B-splines on an interval, Array{Float64}(coefficient order, B-spline index, interval count). This would be three-dimensional with size (m, m, k+1), where there are k+2 points on the axis defining k+1 intervals.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Glissa]","category":"page"},{"location":"reference/#Glissa.DividedDifference","page":"Reference","title":"Glissa.DividedDifference","text":"A recursive implementation of divided differences.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Glissa.NewtonForm","page":"Reference","title":"Glissa.NewtonForm","text":"The Newton form for an interpolating polynomial represents f(x) at points tau by a sum.\n\nsum_i=0^n fx_0ldotsx_iprod_j=0^i-1(x-x_j)\n\nHere, the a are the divided differences and tau are the x[j].\n\n\n\n\n\n","category":"type"},{"location":"reference/#Glissa.NewtonForm-Union{Tuple{T}, Tuple{Vector, Vector{T}}} where T<:Real","page":"Reference","title":"Glissa.NewtonForm","text":"Construct a NewtonForm. From Conte and deBoor 1980, Eqn. 4.8.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.PiecewisePolynomial","page":"Reference","title":"Glissa.PiecewisePolynomial","text":"This is a piecewise polynomial. It has N+1 points on the abcissa, tau. It has N cubic interpolants in c, which is size 4 x N for a cubic spline. At each interval, the polynomial is in Horner Form,\n\nP_i(x) = c_1i + c_2i(x-x_i) + c_3i(x-x_i)^2 + c_4i(x-x_i)^3\n\nThis spline has one type for the abcissa and one for the ordinate coefficients. It should be the case that one(T) * one(X) is of type T.\n\nThis can be a spline of another order. It's just a matter of the dimensions of the coefficient array, c. You would evaluate this with evalpoly(x-τ[i], c[1:end, i]), where i is the interval.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Glissa.RepeatedIndex","page":"Reference","title":"Glissa.RepeatedIndex","text":"RepeatedIndex(multiple::AbstractVector)\n\nUses a multiplicity vector to present a vector as having repeated elements. If a vector is length 3, and multiple is [2, 1, 3], then this index will return the values[1, 1, 2, 3, 3, 3]`.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.:*-Union{Tuple{T}, Tuple{X}, Tuple{PiecewisePolynomial{X, T}, PiecewisePolynomial{X, T}}} where {X, T}","page":"Reference","title":"Base.:*","text":"Multiply two splines of order m1 and m2 to get a spline of order m1+m2. This only works if the two splines have the same abcissa.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.eltype-Union{Tuple{PiecewisePolynomial{X, T}}, Tuple{T}, Tuple{X}} where {X, T}","page":"Reference","title":"Base.eltype","text":"Type of the polynomial constants.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.length-Tuple{PiecewisePolynomial}","page":"Reference","title":"Base.length","text":"Number of vertices in axis, which is 1 + number of intervals\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.bspline_by_matrix!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractVector{Int64}, Any, Any}} where T","page":"Reference","title":"Glissa.bspline_by_matrix!","text":"Calculate coefficients of a b-spline of order m, degree m-1 by sending an axis of length m+1 and a coefficient matrix of size mxm, into which are written columns of coefficients for the polynomial of each interval. If you want a b-spline on a subset of an axis, use an array view for inputs. This is the least efficient way to calculate these coefficients, but it makes explicit the continuity conditions that lead to a solution. i is the index of the leftmost point, counting points by their multiplicity, so a point with multiplicity of 3 is three points.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.bsplineq_recursive-NTuple{4, Any}","page":"Reference","title":"Glissa.bsplineq_recursive","text":"bsplineq(axis, order, index, x)\n\nThis is the Q_i^m(x) B-spline, which is normalized to 1m. Here is is defined by recursion. Needs length(axis) ≤ index + order. The order is 1 or greater.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.bsplineq_recursive-NTuple{5, Any}","page":"Reference","title":"Glissa.bsplineq_recursive","text":"bsplineq(axis, order, index, x, nth_derivative)\n\nThis is the Q_i^m(x) B-spline, which is normalized to 1m. Here is is defined by recursion.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.cubic_spline-Union{Tuple{T}, Tuple{X}, Tuple{AbstractVector{X}, AbstractVector{T}, AbstractVector{T}}} where {X<:Real, T<:Real}","page":"Reference","title":"Glissa.cubic_spline","text":"Creates a cubic spline on abcissa τ with values f and endpoint slopes equal to fp[1] and fp[2].\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.cubic_spline_coefficients!-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Any, Any}} where T<:Real","page":"Reference","title":"Glissa.cubic_spline_coefficients!","text":"Given an abcissa, τ, of length N+1 values f of length N+1, and derivatives s of length N+1, this computes the 4xN matrix c of cubic coefficients. Conte and deBoor Eq. 4.55\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.deboor_swartz_criterion-Union{Tuple{T}, Tuple{T, Any, Any}} where T<:Real","page":"Reference","title":"Glissa.deboor_swartz_criterion","text":"\"Accurate Monotonicity Preserving Cubic Interpolation\" by James M Hyman. 1983.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.degree-Tuple{PiecewisePolynomial}","page":"Reference","title":"Glissa.degree","text":"Polynomial degree, so 2 for x^2\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.derivative-Union{Tuple{PiecewisePolynomial{X, T}}, Tuple{T}, Tuple{X}} where {X, T}","page":"Reference","title":"Glissa.derivative","text":"Given a spline, create a new spline that is its derivative.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.divdiff-Tuple{Any, Any}","page":"Reference","title":"Glissa.divdiff","text":"Definition 2.49 of divided differences from Schumaker. Eqn 2.86.\n\naxis = 0:5 f(x) = 2.3 + 0.5*x^2 - x^3 divdiff(axis, f)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.divdiff_repeats-Tuple{Any, Any}","page":"Reference","title":"Glissa.divdiff_repeats","text":"Divided differences that allow for derivatives. Schumaker page 46-7, eqn 2.89.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.divided_difference-Tuple{Integer, Integer, AbstractVector, Function, Glissa.DividedDifference}","page":"Reference","title":"Glissa.divided_difference","text":"Calculate divided differences of a function f at points τ, using recursion.\n\ntau_i tau_i+1ldotstau_jf\n\nThis calculates the divided difference from τi to τj. The dd is a memoization. If any knots are equal, define f(x,n) where n is how many times to take the derivative.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.divided_difference_explicit-Tuple{Integer, Integer, AbstractVector, Function}","page":"Reference","title":"Glissa.divided_difference_explicit","text":"This explicit divided difference applies only when the axis is distinct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.dprod-Tuple{Any, Any}","page":"Reference","title":"Glissa.dprod","text":"a(a+1)(a+2)cdots(b-1)b\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.evaluate!-Tuple{PiecewisePolynomial, AbstractVector, AbstractVector}","page":"Reference","title":"Glissa.evaluate!","text":"Evaluate a piecewise polynomial at a series of x values and write into y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.evaluate_bspline-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray, Any, T}} where T","page":"Reference","title":"Glissa.evaluate_bspline","text":"evaluate_bspline(c::AbstractArray{T}, y::AbstractArray, m, x::T) where {T}\n\nEvaluate B-spline with coefficients c on axis y of order m at x. This is Algorithm 5.8 from Schumaker.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.generate_normalized_bsplines!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector, Any, Any, T}} where T","page":"Reference","title":"Glissa.generate_normalized_bsplines!","text":"generate_normalized_bsplines!(N::AbstractVector{T}, y::AbstractVector, l, m, x::T) where {T}\n\nGiven x in y_l y_l+1) to generate N^m_l+1-m(x) to N_l^m(x) y is the axis. m is the order of the b-spline. The l is found by a search of the axis, and the axis can have repeated elements. This algorithm applies to axis intervals where y_l+1  y_l, not equal to it. That tells us how to number the expansion coefficients, c. It's Algorithm 5.5 from Schumaker's book.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.global_derivatives!-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Any}} where T<:Real","page":"Reference","title":"Glissa.global_derivatives!","text":"τ are the abcissa from 1 to N+1. f are the known values of length N+1. fp_bounds are derivatives at the first and last endpoint. fp is the output, of length N + 1. This is from Conte and deBoor Sec. 4.8, Eq. 4.60. The equation is this, with i running from 2 to N.\n\n(Delta x_i) s_i-1+2(Delta x_i-1+Delta x_i)s_i +(Delta x_i-1s_i+1) = 3(fx_i-1x_iDelta x_i+fx_ix_i+1Delta x_i-1)\n\nHere, Delta x_i = x_i+1 -xi and\n\nfx_ix_i+1 = fracfx_i+1 - fx_ix_i+1-x_i\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.hyman_coefficients!-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Any, Any}} where T<:Real","page":"Reference","title":"Glissa.hyman_coefficients!","text":"This is how splinefun sets the coefficients. Seems to have the same result as the code above.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.hyman_criterion-Union{Tuple{T}, Tuple{T, Any, Any}} where T<:Real","page":"Reference","title":"Glissa.hyman_criterion","text":"This comes from Hyman's paper but is modified by the R implementation of splinefun, which Simon Wood wrote. I didn't understand from the paper the exact structure of decisions to take in the function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.integral_in_interval-Union{Tuple{T}, Tuple{X}, Tuple{A}, Tuple{PiecewisePolynomial{X, T}, Any, A}} where {A<:Real, X, T}","page":"Reference","title":"Glissa.integral_in_interval","text":"Integrate a spline from a knot at i to the value x.\n\n(((A(1/4)cs.c[4, i] * Δ + A(1/3)cs.c[3, i]) * Δ + A(1/2)cs.c[2, i]) * Δ + cs.c[1, i])Δ\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.integrate-Union{Tuple{A}, Tuple{PiecewisePolynomial, A, A}} where A<:Real","page":"Reference","title":"Glissa.integrate","text":"Integrate a spline from x1 to x2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.normalized_bspline-Union{Tuple{T}, Tuple{Integer, Integer, Vector{T}, T}} where T<:Real","page":"Reference","title":"Glissa.normalized_bspline","text":"An explicit representation of the normalized B-spline.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.order-Tuple{PiecewisePolynomial}","page":"Reference","title":"Glissa.order","text":"The order is one plus the degree of the polynomial.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.piecewise_representation!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractVector}} where T","page":"Reference","title":"Glissa.piecewise_representation!","text":"Algorithm 5.15: Construct a piecewise polynomial representation of a polynomial spline that is represented by spline coefficients. This converts out of B-splines to the polynomial representation. If there are more than about 2 evaluations of each spline interval, this can be more efficient. Each spline i is represented by a polynomial of the form\n\ns_i(x)= sum_j=1^m w_ji (x - tau_i)^j-1\n\nwhere w_ij are polynomial constants for the ith B-spline.\n\nInitialize w = zeros(T, m, n) where n is the number of B-spline coefficients.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.polyspline_constraints!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractVector{Int64}, Any}} where T","page":"Reference","title":"Glissa.polyspline_constraints!","text":"This reads a list of multiplicities and converts that into a matrix that represents the constraints indicated by those multiplicites. The resulting matrix defines the space of the given polynomial spline on this axis.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.project_to_monotonicity!-Tuple{Any, Any, Any}","page":"Reference","title":"Glissa.project_to_monotonicity!","text":"Uses Hyman piecewise monotonicity.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.reduce_axis-Tuple{AbstractVector, Any, Any}","page":"Reference","title":"Glissa.reduce_axis","text":"This extracts from a multiplicity vector the support for the ith B-spline. There is an axis where length(axis)=length(multiplicity). This axis will, in general, support multiple B-splines. This function returns a sub-range of that axis and a new multiplicity vector, the same length as that sub-range. It will be the exact support for the ith B-spline of order order.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.single_polynomial-Union{Tuple{X}, Tuple{T}, Tuple{Vector{X}, Vector{T}}} where {T<:Real, X<:Real}","page":"Reference","title":"Glissa.single_polynomial","text":"Given an axis τ and values f on that axis, return a polynomial y such that\n\ny(τi) = fi\n\nConstruct a polynomial that interpolates a function, using polynomials with zeroes. This should match the constructor above. It comes from deBoor equation 4.2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.splinen_divided-NTuple{4, Any}","page":"Reference","title":"Glissa.splinen_divided","text":"An N version of the B-spline on an axis y, order m, index i, at x. This version is defined using divided differences.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.splineq_divided-NTuple{4, Any}","page":"Reference","title":"Glissa.splineq_divided","text":"A Q version of the B-spline on an axis y, order m, index i, at x. This version is defined using divided differences.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.truncated-NTuple{4, Any}","page":"Reference","title":"Glissa.truncated","text":"A truncated function with a derivative with respect to c.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.truncated-Tuple{Any, Any, Any}","page":"Reference","title":"Glissa.truncated","text":"This is the truncated function that defines the Q B-spline.\n\n(x - c)_+^k\n\nIt's only defined when x  c.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glissa.vandermonde_determinant_repeats-Tuple{Any, Any}","page":"Reference","title":"Glissa.vandermonde_determinant_repeats","text":"The equation 2.67 in Schumaker is hard to understand. It reads, exactly,\n\nV(t_1ldotst_m)=prod_1le ijle d(tau_j-tau_i)^l_jl_i prod_i=1^dprod_nu=1^l_i-1nu\n\nThe LHS goes to m to count the total length of the axis. The RHS uses d which is the number of unique values. I have a hard time believing it's a product of factorials at the end. Maybe he wanted just a single product over the factorial?\n\nprod_i=1^d (l_i-1)\n\nLet's check it.\n\n\n\n\n\n","category":"method"},{"location":"bsplines/#B-splines","page":"B-splines","title":"B-splines","text":"","category":"section"},{"location":"bsplines/#Introduction","page":"B-splines","title":"Introduction","text":"","category":"section"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"The Wikipedia B-spline article tells you how to calculate them but doesn't describe what defines a B-spline. That definition will be useful for deriving, understanding, and testing algorithms, so let's cover it here.","category":"page"},{"location":"bsplines/#Compare-with-polynomials-for-interpolation","page":"B-splines","title":"Compare with polynomials for interpolation","text":"","category":"section"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"The Notation section described polynomial splines as a set of polynomials defined on neighboring intervals. For computational purposes, we don't usually represent polynomial splines as a list of polynomial constants. Instead, we use B-splines, because they are a more compact representation and offer advantages for computations using polynomial splines.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"On an axis with points at (0, 1, 2, 3, 4), with free boundary conditions, there are 6 degree-2 B-splines.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"(Image: Order 3 Splines)","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"Each B-spline is a function that's defined over the whole interval, but, at the same time, it's only non-zero over at-most d contiguous intervals.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"Imagine that our goal is to fit data with a polynomial spline. We have points to fit, and they are between some x_1 and x_k+2, where we call the endpoint k+2 so that the count of internal knots is k. The first step is to divide the axis into intervals. At each knot where intervals meet, we get to decide, beforehand, whether the fit polynomial should be C^0-smooth (continuous), C^1-smooth (once differentiable), or as smooth as possible C^d-1-smooth. We can choose this knot-by-knot, if we want.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"Now how would we do this fit with polynomials? For each interval, there is a separate polynomial y_j.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"y_j(x) = sum_i=1^i=m c_ij (x-x_j)^i-1","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"We could fit the points in order to find the c_ij constants. For k+1 intervals on k knots, there would be (d+1)(k+1) constants to choose. When solving for the constants, we need to include equations that assert smoothness across the knots.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"On the other hand, B-splines are functions that are designed, from their definition, to obey smoothness constraints. If constraints are built into the B-spline, we don't need to include equations to assert those same constraints. There are also fewer constants to choose becasue the final fit will be a sum of the B-splines.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"y(x) = sum_j c_j B_j(x)","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"That means there are exactly as many constants c_j as we have degrees of freedom in the problem. If we are fitting with maximally-smooth polynomials, then there are k+2d B-splines, total. And, as a neat trick, we don't need to store the polynomials that define the B_j(x). They are quick to calculate from the knots.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"Prefiltering is a name for finding the c_j values that make a set of B-splines interpolate a set of points. You're taking data points (x_p y_p) and solving for the c_j that make a B-spline-defined polynomial that matches them.","category":"page"},{"location":"bsplines/#B-spline-definition-from-its-constraints","page":"B-splines","title":"B-spline definition from its constraints","text":"","category":"section"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"B-splines are a basis set for polynomial splines on a particular axis, x_1  x_2  x_3 ldots  x_k+2, with a given set of natural boundary conditions. Because they are a basis set, every allowable polynomial spline with those boundary conditions can be written as a sum of the B-splines for that axis. The set of B-splines reduces the amount of storage needed for a polynomial spline and reduces the computation needed to fit points with a polynomial spline. Now, how could we calculate the polynomial representation of any one of the B-splines for a given axis?","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"Let's compute the polynmial coefficients c_ij that define a single B-spline on an axis. Start by picking a left-most point, some x_j. Then the B-spline will be zero to the left, positive for some number of intervals, say p intervals. And then it will be zero to the right of that. We can count the unknown values as p intervals of polynomials of degree d, so there are p(d+1) unknown values. Oddly, we don't know the number of intervals for this B-spline yet, but continuity conditions will tell us what p must be.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"Each continuity condition, at the knot between two intervals, is a constraint on the B-spline, and the sum of the number of constraints must equal the number of unknown polynomial constants, in order for this B-spline to be well-defined. If the multiplicity of each knot is 1, then the number of constraints is d. In general, there are d+1-m_j constraints at each knot, where m_j is knot multiplicity. Over p intervals, that makes (p-1)(d+1) - sum_j m_j constraints.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"There are two other kinds of constraints. We use a normalization of the B-spline to define how tall it will be, which is one constraint. We can also add boundary conditions. Let's first consider the case where the B-spline goes to zero at both sides, with C^d-1 smoothness and has single multiplicity at each knot. That means there are d boundary conditions at each side. If we balance our unknowns with our constraints, that will tell us how many intervals wide this B-spline extends.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"p(d+1)= (p-1)d + 1 + 2d","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"The solution to this is that p=d+1. For a smooth polynomial spline, the B-spline for d=2 has 3 pieces. For a degree d=3 B-spline, there are 4 pieces, and there is a more general form that holds true when there is less smoothness.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"We can have up to 2d boundary conditions, so let's call that ble 2d. Recall that boundary conditions can be encoded as multiplicity, where a multiplicity of 1 enforces all possible conditions and a multiplicity of d+1 enforces no boundary conditions at that side.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"b=2d+2-m_1-m_p+1","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"We can also have knots with higher multiplicity, which reduces the total number of constraints. Note that the j in this equation runs over internal knots, so it doesn't include endpoints and there will be (p-1) values of j.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"p(d+1) = (p-1)(d+1) - sum_j=2^p m_j + 1 + b","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"If we simplify this equation, it looks like p drops out, but there are p-1 values of m_j, and usually m_j=1 for all knots. The boundary conditions, as well, are ble 2d.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"sum_j=2^p m_j = b - d","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"As a check, our simple example has multiplicity 1 and 2d=4 boundary conditions, so 1+1 = 4 - 2, so math still works. Let's substitute multiplicity at endpoints for b.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"sum_j=2^p m_j = 2d+2-m_1-m_p+1 - d","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"This simplifies to a formulat that says that, if you represent your boundary conditions and continuity with B-splines, then every consecutive set of points, where the sum of the multiplicity is d+2, is the domain of another B-spline.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"sum_j=1^p+1 m_j = d+2","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"We can walk along the array of multiplicity values in order to generate B-spline polynomials. I'll write this as code so that you can see that we walk not by vertex but by multiple of the vertices, as though they were written out as an ordered array that had duplicates.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"function every_bspline_on_axis(x::AbstractArray, multiplicity::AbstractArray)\n    # -1 because the last point has no B-spline to the right.\n    bspline_count = sum(multiplicity) - 1\n    bsplines = []\n    vertex_index = 1\n    multiplicity_index = 1\n    while vertex_index <= bspline_count\n        push!(bsplines, generate_bspline(x, multiplicity, vertex_index, multiplicity_index))\n        multiplicity_index += 1\n        if multiplicity_index > multiplicity[vertex_index]\n            vertex_index += 1\n            multiplicity_index = 1\n        end\n    end\nend","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"As a mental check, can a single interval have a B-spline? It has no knots. We see that a B-spline, in this case, is well-defined because there is a solution to 0=b-d, by setting b boundary conditions at the left-hand side x_l and right-hand side x_r. For the case of degree 2, there are three ways to do this. 1. Set f(x_l)=0, f(x_l)=0. 2. Set f(x_l)=0 and f(x_r)=0. 3. Set f(x_r)=0 and f(x_r)=0. It turns out that every interval has d+1 splines defined that are nonzero on that interval, no matter what the boundary conditions are.","category":"page"},{"location":"bsplines/#How-to-count-B-splines-with-multiplicity","page":"B-splines","title":"How to count B-splines with multiplicity","text":"","category":"section"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"I'm wondering how to write an algorithm for B-splines that uses multiplicity instead of creating an axis that has repeated values where there are knots. When there is an axis, the answer is simple. If there k+1 points on the axis, then there are k+1-m B-splines. The i-th B-spline is at axis point tau_i. It's straightforward, but this changes when using multiplicity.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"The count of axis points is related to the cumulative multiplicity.","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"M_j = sum_i=1^j m_i","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"The i-th B-spline can be written in terms of multiplicity if we think of it as having i-1 cumulative multiplicity to the left of it. If we are looking at interval j, then M_j is the total number of axis points to the left. That means the last B-spline to cover this interval is M_j and the first B-spline to cover it will be M_j-m + 1, where m is the order.","category":"page"},{"location":"bsplines/#Calculating-B-splines","page":"B-splines","title":"Calculating B-splines","text":"","category":"section"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"We don't calculate the polynomial representation of B-splines. We don't need to, because there are nifty functions that evaluate B-splines without calculating their polynomial constants. The best source for this is Schumaker's Spline Functions: Basic Theory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Glissa","category":"page"},{"location":"#Glissa","page":"Home","title":"Glissa","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Glissa is a Julia library that defines B-splines for non-uniform interpolation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Interpolations.jl package in Julia doesn't support non-uniform interpolation or interpolations with multiple knots (less smooth interpolation), so this package is a place to implement and test basic functions with which to expand functionality of Interpolations.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are many implementations of B-splines here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Iterative B-splines - The most robust computation of a B-spline, implemented for non-uniform axes and repeated knots. This includes derivatives and integrals. bspline.jl.\nRecursive B-splines - The most common way to define a B-spline is to use recursion. recursive.jl\nDivided differences B-splines - This is a function-on-a-function that is one way to define a B-spline. It's a theoretically-simple definition not normally used for computation, but Julia makes the computation nice enough. divided_differences.jl\nConstraint-solved B-splines - You can set up a set of equations on polynomial pieces, where these equations define the B-spline. This is an excellent check on other methods. bsplineconstriants.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are also some other representations of splines, used for comparison.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Polynomial Pieces - This represents a set of polynomials defined on contiguous intervals. Sometimes we convert splines into this space. piecewise.jl\nCubic spline fit - Interpolate data with cubic polynomials. This is an old-school polynomial function. This fit can also be done with splines, so we can use this for testing. (from Conte and de Boore's book). cubic_spline.jl\nNewton form - A nice way to solve for a polynomial fit, from Conte and de Boor. newton_form.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"The source material for this work is a set of standard implementations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Conte and de Boor's Elementary Numerical Analysis.\nSchumaker's Spline Functions: Basic Theory, 3rd Ed. Schumaker also has a recent book on SplinePak for Matlab. It's not a book as much as documentation, but it's a good overview of how implementations fit together to do a job.\nDierckx's book on spline functions.","category":"page"},{"location":"testspaces/#Testing-B-splines","page":"Testing B-splines","title":"Testing B-splines","text":"","category":"section"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"We can test well if we focus on theoretical properties that define B-splines. If this set of theoretical properties is mathematically enough to define B-splines, then we don't need any more tests.","category":"page"},{"location":"testspaces/#Locality,-positivity,-and-normalization","page":"Testing B-splines","title":"Locality, positivity, and normalization","text":"","category":"section"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"For both Q-splines and N-splines, they are zero outside of their domain, where the domain for Q_i^m(x) is tau_i le x  tau_i+m. They must be positive within that domain with normalization for Q(x) such that the first moment is 1m.","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"int_tau_i^tau_i+mQ_i^m(x)dx = 1m","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"The second moment is also known.","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"int_tau_i^tau_i+mxQ_i^m(x)dx = fracsum_j=i^i+mtau_jm(m+1)","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"and, for the normalized splines, there is a factor that makes the integral smaller for smaller intervals, which can keep numbers in better check. So we can check how the normalized spline relates to the unnormalized.","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"N_i^m(x)=(tau_i+m-tau_i)Q_i^m(x)","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"We also know, for normalized splines, that all splines which intersect a point on the axis, will add up to one.","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"sum_i=j+1-m^jN_i^m(x) = 1","category":"page"},{"location":"testspaces/#Spans-a-space","page":"Testing B-splines","title":"Spans a space","text":"","category":"section"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"The main claim of B-splines is that they are a local basis for a space of polynomial splines. We can test that by constructing random polynomial splines that obey the rules of the axis and knots, then solving for the B-spline constants that fit them. Our test is that the resulting splines fit the values exactly. We need to make polynomial splines first.","category":"page"},{"location":"testspaces/#Build-a-random-polynomial-spline","page":"Testing B-splines","title":"Build a random polynomial spline","text":"","category":"section"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"These polynomial splines are defined on an axis, (tau_1 tau_2ldotstau_k) where there are a specified number of boundary conditions at each side, all of which, in this case set the value or a derivative to zero. There are also join conditions on the knots, as specified by multiplicity. We can express this as a set of equations. Define a column vector out of the polymonial coefficients for each polynomial piece on an interval, vecc. So that's (c_11 c_21 c_31 c_12 c_22ldots) for a set of polynomials where interval j is sum_i c_i (x-tau_j)^i-1. Our equations will look like a matrix.","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"Avecc = vecb","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"The A are continuity equations at boundary conditions and knots. The vecb are all zeros, because these equations assert either that the boundary condition is zero or that two knots are continuous up to some derivative, which relates the knots on the left, again leaving a zero on the right-hand side. OK, we have more unknowns, vecc than we have equations. That makes A an mtimes n matrix where nm. How can we generate consistent c values?","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"The generalized inverse lets us make these. If we take the singular value decomposition, the truncated version with tildes,","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"A=tildeUtildeSigmatildeV^*","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"and take its inverse, we get A^dag=tildeVtildeSigma^-1tildeU^*. Then we can make many vecc by projection.","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"vecc=A^dagb + (I-A^dagA)vecw","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"The vecw can be any values we want. The first term is a solution to the equations, and the second term is removing from our choice of vecw all contributions that don't solve the equations.","category":"page"},{"location":"testspaces/#Find-a-B-spline-approximation-to-values-generated-from-that-polynomial-spline","page":"Testing B-splines","title":"Find a B-spline approximation to values generated from that polynomial spline","text":"","category":"section"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"So we can generate a random vector vecw which gives us a polynomial spline defined by vecc. At this point, if we can find a linear combination of splines that matches that polynomial spline, then that's a good test. We set up that question as an equation, too.","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"Here, the unknown vecx is the set of coefficients of all B-splines defined for an axis. For each of these, let's generate a bunch of points from every interval on the axis, If the order is m, then generate at least m points for each interval tau_i le x  tau_i+1. These are our vecy on the right-hand side of an equation.","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"Mvecx=vecy","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"The matrix M is created by making one row for each B-spline and one column for each of the sample points. Then we do a linear regression on this to get a closest set of vecx.","category":"page"},{"location":"testspaces/#Estimate-error-between-observed-and-fit","page":"Testing B-splines","title":"Estimate error between observed and fit","text":"","category":"section"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"Finally, estimate the error.","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"vecy-Mvecx","category":"page"},{"location":"testspaces/","page":"Testing B-splines","title":"Testing B-splines","text":"That should be very small for all vecw we can create. We can run this in a loop with randomly-generated polynomial splines.","category":"page"},{"location":"notation/#Notation","page":"Notation","title":"Notation","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"This defines terms in order to help read the code.","category":"page"},{"location":"notation/#Polynomial","page":"Notation","title":"Polynomial","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"A polynomial is a function of x, relative to some x_j, with constants c_i, of the form","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"p_j(x) = c_1 + c_2 (x - x_j) + c_3 (x - x_j)^2 = sum_i=1^i=d+1c_i(x-x_j)^i-1","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"The polynomial above has a degree of d=2 because (x-x_1)^2 is the largest power. It has order m=3 because there are 3 constants (c_1 c_2 c_3). By definition, m=d+1. In Julia, you can evaluate a polynomial with evalpoly.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"c1, c2, c3 = rand(3)\ny = evalpoly(1.4, [c1, c2, c3])","category":"page"},{"location":"notation/#Piecewise-Polynomial","page":"Notation","title":"Piecewise Polynomial","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"Separate the x-axis into (x_1 x_2 x_3 x_4 x_k+2) so that there are k + 1 intervals, where interval j is the axis between x_j and x_j+1, not including the endpoint x_j+1 which makes the interval closed on the left and open on the right. Now define a polynomial on each interval. Each of these is a polynomial piece. The x_2ldots x_k+1-values, which excludes the endpoints, are called knots.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"We need two indices on the constants, row i for the polynomial constant and column j for the polynomial piece, so they are now c_ij. In addition, we assume all polynomial pieces have the same degree. That does not need to be the case, and it may be useful for some computations to relax this assumption.","category":"page"},{"location":"notation/#Polynomial-Spline","page":"Notation","title":"Polynomial Spline","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"The piecewise polynomial above makes no guarantees that neighboring intervals will be continuous. If the value of the polynomial in one interval is continuous with the value of the neighboring polynomial, it's called C^0 smooth. If, in addition to being continuous, the first derivatives match, then it's C^1 smooth. For matching second derivatives, that's C^2 smooth.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"A polynomial spline with simple knots is a piecewise polynomial, of degree d, which is C^d-1 smooth at each knot. It couldn't be any more smooth, because if we say, for instance, that two second-degree polynomials have the same values and derivatives, all the way up to second derivatives, then they are the same polynomial because they have to have the same polynomial constants.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"A general polynomial spline guarantees that you don't have a situation where the derivatives agree across a knot, but the values aren't continuous. That may seem weird, but it's useful for some kinds of integration. Because of this restriction, we can think of each knot as having its own continuity condition. For instance, for a quadratic spline, each knot could be C^0 or C^1. For a quadratic spline, each knot could be C^0, C^1, C^2, or C^3.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"The multiplicity of a knot indicates its smoothness. For a degree d polynomial, a multiplicity m_j=1 know has maximal smoothness, which is C^d-1. As multiplicity increases, smoothness across the knot decreases. The maximum multiplicity is m_j=m, where m=d+1 is the order of the polynomial. When m_j=m, then the two neighboring polynomial pieces are disconnected. Note that endpoints aren't knots, just places where intervals meet. In code, an array m[i] is a multiplicity vector, but an integer m is the order.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"There is another way to represent knot multiplicity. When listing the knots, repeat values for the knots of higher multiplicity, so an order 3 polynomial with multiplicity m_j=2 for its internal knots would have knot values of (x_1 x_1 x_1 x_2 x_2 x_3 x_3 x_4 x_4 x_4). The knots on the boundaries will appear m times when the polynomial spline is discontinuous at the boundary. Some algorithms rely on neighboring knots sometimes being equal to express multiplicity.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"There is some sense to using the word, multiplicity, to denote smoothness of splines. If three neighboring intervals are C^2 smooth, and you drag the knots together, shrinking the middle interval, the resulting neighboring intervals will only be C^1 smooth. Overlapping knots are equivalent to reduced continuity.","category":"page"},{"location":"notation/#Boundary-conditions","page":"Notation","title":"Boundary conditions","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"At the left-most x_1 and the right-most x_k+1, we can define boundary conditions. A boundary condition is a specific value for the j-th derivative of the polynomial at that boundary. We will discuss so-called natural boundary conditions, meaning that we require the polynomial value to be 0 at the boundary, or its value and first derivative both to be 0, or its value and first two derivatives to be 0, and so on.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"For a degree d=2 polynomial, we can require the value to be zero and the first derivative to be zero. That's up to 2 boundary conditions. If we required more, it would set the polynomial to be zero within the interval neighboring the boundary.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"A boundary condition at x_1 or x_k+1 is kind of like a continuity condition with some polynomial piece that's outside the axis of the polynomial spline. Because of this similarity, we can represent boundary conditions by 1) defining values for a neighboring polynomial on each side and 2) assigning a multiplicity to the endpoints the same way we assign multiplicity to the knots. In this case, a multiplicity of 1 means that, at the endpoint, the polynomial piece is C^d-1 continuous with the polynomial outside. A multiplicity of d+1 means there is no continuity, so there are no boundary conditions at that endpoint.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Degree Boundary Multiplicity Continuity with Zero\n2 3 not continuous\n2 2 C^0 continuous\n2 1 C^1, once differentiable\n3 4 not continuous\n3 3 C^0\n3 2 C^1\n3 1 C^2 twice differentiable","category":"page"}]
}
