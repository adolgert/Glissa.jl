<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Testing B-splines · Glissa.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://adolgert.github.io/Glissa.jl/testspaces/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Glissa.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../notation/">Notation</a></li><li><a class="tocitem" href="../bsplines/">B-splines</a></li><li class="is-active"><a class="tocitem" href>Testing B-splines</a><ul class="internal"><li><a class="tocitem" href="#Locality,-positivity,-and-normalization"><span>Locality, positivity, and normalization</span></a></li><li><a class="tocitem" href="#Spans-a-space"><span>Spans a space</span></a></li><li><a class="tocitem" href="#Find-a-B-spline-approximation-to-values-generated-from-that-polynomial-spline"><span>Find a B-spline approximation to values generated from that polynomial spline</span></a></li><li><a class="tocitem" href="#Estimate-error-between-observed-and-fit"><span>Estimate error between observed and fit</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../projectplan/">Project Plan</a></li><li><a class="tocitem" href="../testplan/">Test Plan</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Testing B-splines</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Testing B-splines</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/adolgert/Glissa.jl/blob/main/docs/src/testspaces.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Testing-B-splines"><a class="docs-heading-anchor" href="#Testing-B-splines">Testing B-splines</a><a id="Testing-B-splines-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-B-splines" title="Permalink"></a></h1><p>We can test well if we focus on theoretical properties that define B-splines. If this set of theoretical properties is mathematically enough to define B-splines, then we don&#39;t need any more tests.</p><h2 id="Locality,-positivity,-and-normalization"><a class="docs-heading-anchor" href="#Locality,-positivity,-and-normalization">Locality, positivity, and normalization</a><a id="Locality,-positivity,-and-normalization-1"></a><a class="docs-heading-anchor-permalink" href="#Locality,-positivity,-and-normalization" title="Permalink"></a></h2><p>For both Q-splines and N-splines, they are zero outside of their domain, where the domain for <span>$Q_i^m(x)$</span> is <span>$\tau_i \le x &lt; \tau_{i+m}$</span>. They must be positive within that domain with normalization for <span>$Q(x)$</span> such that the first moment is <span>$1/m$</span>.</p><p class="math-container">\[\int_{\tau_i}^{\tau_{i+m}}Q_i^m(x)dx = 1/m\]</p><p>The second moment is also known.</p><p class="math-container">\[\int_{\tau_i}^{\tau_{i+m}}xQ_i^m(x)dx = \frac{\sum_{j=i}^{i+m}\tau_j}{m(m+1)}\]</p><p>and, for the normalized splines, there is a factor that makes the integral smaller for smaller intervals, which can keep numbers in better check. So we can check how the normalized spline relates to the unnormalized.</p><p class="math-container">\[N_i^m(x)=(\tau_{i+m}-\tau_i)Q_i^m(x)\]</p><p>We also know, for normalized splines, that all splines which intersect a point on the axis, will add up to one.</p><p class="math-container">\[\sum_{i=j+1-m}^{j}N_i^m(x) = 1\]</p><h2 id="Spans-a-space"><a class="docs-heading-anchor" href="#Spans-a-space">Spans a space</a><a id="Spans-a-space-1"></a><a class="docs-heading-anchor-permalink" href="#Spans-a-space" title="Permalink"></a></h2><p>The main claim of B-splines is that they are a local basis for a space of polynomial splines. We can test that by constructing random polynomial splines that obey the rules of the axis and knots, then solving for the B-spline constants that fit them. Our test is that the resulting splines fit the values exactly. We need to make polynomial splines first.</p><h3 id="Build-a-random-polynomial-spline"><a class="docs-heading-anchor" href="#Build-a-random-polynomial-spline">Build a random polynomial spline</a><a id="Build-a-random-polynomial-spline-1"></a><a class="docs-heading-anchor-permalink" href="#Build-a-random-polynomial-spline" title="Permalink"></a></h3><p>These polynomial splines are defined on an axis, <span>$(\tau_1, \tau_2,\ldots,\tau_k)$</span> where there are a specified number of boundary conditions at each side, all of which, in this case set the value or a derivative to zero. There are also join conditions on the knots, as specified by multiplicity. We can express this as a set of equations. Define a column vector out of the polymonial coefficients for each polynomial piece on an interval, <span>$\vec{c}$</span>. So that&#39;s <span>$(c_{11}, c_{21}, c_{31}, c_{12}, c_{22}\ldots)$</span> for a set of polynomials where interval <span>$j$</span> is <span>$\sum_i c_i (x-\tau_j)^{i-1}$</span>. Our equations will look like a matrix.</p><p class="math-container">\[A\vec{c} = \vec{b}\]</p><p>The <span>$A$</span> are continuity equations at boundary conditions and knots. The <span>$\vec{b}$</span> are all zeros, because these equations assert either that the boundary condition is zero or that two knots are continuous up to some derivative, which relates the knots on the left, again leaving a zero on the right-hand side. OK, we have more unknowns, <span>$\vec{c}$</span> than we have equations. That makes <span>$A$</span> an <span>$m\times n$</span> matrix where <span>$n&gt;m$</span>. How can we generate consistent <span>$c$</span> values?</p><p>The generalized inverse lets us make these. If we take the singular value decomposition, the truncated version with tildes,</p><p class="math-container">\[A=\tilde{U}\tilde{\Sigma}\tilde{V}^*\]</p><p>and take its inverse, we get <span>$A^{\dag}=\tilde{V}\tilde{\Sigma}^{-1}\tilde{U}^*$</span>. Then we can make many <span>$\vec{c}$</span> by projection.</p><p class="math-container">\[\vec{c}=A^{\dag}b + (I-A^{\dag}A)\vec{w}\]</p><p>The <span>$\vec{w}$</span> can be any values we want. The first term is a solution to the equations, and the second term is removing from our choice of <span>$\vec{w}$</span> all contributions that don&#39;t solve the equations.</p><h2 id="Find-a-B-spline-approximation-to-values-generated-from-that-polynomial-spline"><a class="docs-heading-anchor" href="#Find-a-B-spline-approximation-to-values-generated-from-that-polynomial-spline">Find a B-spline approximation to values generated from that polynomial spline</a><a id="Find-a-B-spline-approximation-to-values-generated-from-that-polynomial-spline-1"></a><a class="docs-heading-anchor-permalink" href="#Find-a-B-spline-approximation-to-values-generated-from-that-polynomial-spline" title="Permalink"></a></h2><p>So we can generate a random vector <span>$\vec{w}$</span> which gives us a polynomial spline defined by <span>$\vec{c}$</span>. At this point, if we can find a linear combination of splines that matches that polynomial spline, then that&#39;s a good test. We set up that question as an equation, too.</p><p>Here, the unknown <span>$\vec{x}$</span> is the set of coefficients of all B-splines defined for an axis. For each of these, let&#39;s generate a bunch of points from every interval on the axis, If the order is <span>$m$</span>, then generate at least <span>$m$</span> points for each interval <span>$\tau_i \le x &lt; \tau_{i+1}$</span>. These are our <span>$\vec{y}$</span> on the right-hand side of an equation.</p><p class="math-container">\[M\vec{x}=\vec{y}\]</p><p>The matrix <span>$M$</span> is created by making one row for each B-spline and one column for each of the sample points. Then we do a linear regression on this to get a closest set of <span>$\vec{x}$</span>.</p><h2 id="Estimate-error-between-observed-and-fit"><a class="docs-heading-anchor" href="#Estimate-error-between-observed-and-fit">Estimate error between observed and fit</a><a id="Estimate-error-between-observed-and-fit-1"></a><a class="docs-heading-anchor-permalink" href="#Estimate-error-between-observed-and-fit" title="Permalink"></a></h2><p>Finally, estimate the error.</p><p class="math-container">\[|\vec{y}-M\vec{x}|\]</p><p>That should be very small for all <span>$\vec{w}$</span> we can create. We can run this in a loop with randomly-generated polynomial splines.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bsplines/">« B-splines</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 3 October 2022 14:02">Monday 3 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
